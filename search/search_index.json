{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"# Molecular Systems Automated Identification of Cooperativity MoSAIC is an unsupervised method for correlation analysis which automatically detects the collective motion in MD simulation data, while simultaneously identifying uncorrelated coordinates as noise. Hence, it can be used as a feature selection scheme for Markov state modeling or simply to obtain a detailed picture of the key coordinates driving a biomolecular process.  It is based on the Leiden community detection algorithm which is used to bring a correlation matrix in a block-diagonal form.  The method was published in: &gt; **Correlation-Based Feature Selection to Identify Functional Dynamics in Proteins**   &gt; G. Diez, D. Nagel, and G. Stock,   &gt; *J. Chem. Theory Comput.* **2022** 18 (8), 5079-5088,   &gt; doi: [10.1021/acs.jctc.2c00337](https://pubs.acs.org/doi/10.1021/acs.jctc.2c00337)  If you use this software package, please cite the above mentioned paper.  ## Features - Intuitive usage via [module](#module---inside-a-python-script) and via [CI](#ci---usage-directly-from-the-command-line) - Sklearn-style API for fast integration into your Python workflow - No magic, only a  single parameter which can be optimized via cross-validation - Extensive [documentation](https://moldyn.github.io/MoSAIC) and detailed discussion in publication - Step by step [tutorial](https://moldyn.github.io/MoSAIC/tutorial/t4l_tutorial_github/) to follow   ## Installation The package is called `mosaic-clustering` and is available via [PyPI](https://pypi.org/project/mosaic-clustering) or [conda](https://anaconda.org/conda-forge/mosaic-clustering). To install it, simply call: <pre><code>python3 -m pip install --upgrade mosaic-clustering\n</code></pre> or <pre><code>conda install -c conda-forge mosaic-clustering\n</code></pre>  or for the latest dev version <pre><code># via ssh key\npython3 -m pip install git+ssh://git@github.com/moldyn/MoSAIC.git\n\n# or via password-based login\npython3 -m pip install git+https://github.com/moldyn/MoSAIC.git\n</code></pre>  In case one wants to use the deprecated `UMAPSimilarity` or the module `mosaic umap` one needs to specify the `extras_require='umap'`, so <pre><code>python3 -m pip install --upgrade moldyn-mosaic[umap]\n</code></pre>  ### Shell Completion Using the `bash`, `zsh` or `fish` shell click provides an easy way to provide shell completion, checkout the [docs](https://click.palletsprojects.com/en/8.0.x/shell-completion). In the case of bash you need to add following line to your `~/.bashrc` <pre><code>eval \"$(_MOSAIC_COMPLETE=bash_source mosaic)\"\n</code></pre>  ## Usage In general one can call the module directly by its entry point `$ MoSAIC` or by calling the module `$ python -m mosaic`. The latter method is preferred to ensure using the desired python environment. For enabling the shell completion, the entry point needs to be used.  ### CI - Usage Directly from the Command Line The module brings a rich CI using [click](https://click.palletsprojects.com). Each module and submodule contains a detailed help, which can be accessed by <pre><code>$ python -m mosaic\nUsage: python -m mosaic [OPTIONS] COMMAND [ARGS]...\n\n  MoSAIC motion v0.4.1\n\n  Molecular systems automated identification of collective motion, is\n  a correlation based feature selection framework for MD data.\n  Copyright (c) 2021-2023, Georg Diez and Daniel Nagel\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  clustering  Clustering similarity matrix of coordinates.\n  similarity  Creating similarity matrix of coordinates.\n  tui         Open Textual TUI for interactive usage.\n</code></pre> For more details on the submodule one needs to specify one of the two commands, or by opening the terminal user interface (tui).  A simple workflow example for clustering the input file `input_file` using correlation and Leiden with CPM and the default resolution parameter: <pre><code># creating correlation matrix\n$ python -m mosaic similarity -i input_file -o output_similarity --metric correlation -v\n\nMoSAIC SIMILARITY\n~~~ Initialize similarity class\n~~~ Load file input_file\n~~~ Fit input\n~~~ Store similarity matrix in output_similarity\n\n# clustering with CPM and default resolution parameter\n# the latter needs to be fine-tuned to each matrix\n$ python -m mosaic clustering -i output_similarity -o output_clustering --plot -v\n\nMoSAIC CLUSTERING\n~~~ Initialize clustering class\n~~~ Load file output_similarity\n~~~ Fit input\n~~~ Store output\n~~~ Plot matrix\n</code></pre> This will generate the similarity matrix stored in `output_similarity`, the plotted result in `output_clustering.matrix.pdf`, the raw data of the matrix in `output_clustering.matrix` and a file containing in each row the indices of a cluster.  ### Module - Inside a Python Script <pre><code>import mosaic\n\n# Load file\n# X is np.ndarray of shape (n_samples, n_features)\n\nsim = mosaic.Similarity(\n    metric='correlation',  # or 'NMI', 'GY', 'JSD'\n)\nsim.fit(X)\n\n\n# Cluster matrix\nclust = mosaic.Clustering(\n    mode='CPM',  # or 'modularity\n)\nclust.fit(sim.matrix_)\n\nclusters = clust.clusters_\nclusterd_X = clust.matrix_\n...\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is inspired by Keep a Changelog, and Element and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added-features-and-improvements","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added trogon terminal user interface for easier usage of CI</li> </ul>"},{"location":"changelog/#other-changes","title":"Other changes:","text":"<ul> <li>Fixed minor issues in docs</li> </ul>"},{"location":"changelog/#041-2023-04-04","title":"0.4.1 - 2023-04-04","text":""},{"location":"changelog/#api-changes-warning","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Removed the <code>grid_b</code> keyword from all plot examples to support a broader   range of matplotlib versions.</li> <li>Removed <code>prettypyplot</code> dependency</li> <li>Added <code>matplotlib</code> dependency</li> </ul>"},{"location":"changelog/#added-features-and-improvements_1","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Now checking whether all features have a non-zero and finite standard deviation</li> </ul>"},{"location":"changelog/#040-2023-03-28","title":"0.4.0 - 2023-03-28","text":""},{"location":"changelog/#api-changes-warning_1","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Class <code>UMAPSimilarity</code> was removed</li> </ul>"},{"location":"changelog/#added-features-and-improvements_2","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added py3.11 support</li> <li>All new MkDocs, including tutorials \ud83c\udf89</li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes:","text":"<ul> <li>Fixed CI's</li> </ul>"},{"location":"changelog/#032-2022-09-21","title":"0.3.2 - 2022-09-21","text":""},{"location":"changelog/#other-changes_2","title":"Other changes:","text":"<ul> <li>Update reference and add <code>CITATION.cff</code></li> </ul>"},{"location":"changelog/#bugfix","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fixing <code>AssertionError</code> when Similarity matrix is not in range [0, 1], see #9</li> <li>Add support for <code>numpy&gt;=1.23.0</code>, #13</li> <li>Fix support for <code>prettypyplot&lt;0.8.x</code>, #11</li> </ul>"},{"location":"changelog/#031-2022-08-04","title":"0.3.1 - 2022-08-04","text":""},{"location":"changelog/#bugfix_1","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fixing floating-point error for <code>np.float16, np.float32</code> in <code>Similarity().fit()</code>, see #9</li> </ul>"},{"location":"changelog/#other-changes_3","title":"Other changes:","text":"<ul> <li>Use deprecated decorator for <code>UMAPSimilarity</code></li> <li>Refactor all type definitions</li> <li>Ensure using the same MODES, METRICS, and NORMS  in the cli and the package itself</li> </ul>"},{"location":"changelog/#030-2022-07-22","title":"0.3.0 - 2022-07-22","text":""},{"location":"changelog/#api-changes-warning_2","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Module <code>tools</code> was renamed to <code>utils</code></li> <li><code>load_clusters</code> needs to be accessed via <code>mosaic.utils</code></li> <li>Change the default precision from <code>half</code> to <code>single</code> in CI (<code>__main__.py</code>)</li> <li>Rename in <code>Similarity</code> class the parameter <code>online</code> to <code>low_memory</code> and in   <code>mosaic similarity</code> the flag <code>--online</code> to <code>--low-memory</code></li> <li>Rename in <code>Similarity</code> class the parameter <code>knn_estimator</code> to <code>use_knn_estimator</code></li> <li><code>Similarity.fit</code> and <code>Clustering.fit</code> are returning <code>self</code> which allows a   chaining like <code>sim = Similarity().fit(X)</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_3","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li><code>GridSearchCV</code> class was added, allowing for easy silhouette-CV basedr   parameter search</li> <li><code>Similarity</code> class derives now from <code>sklearn.base.BaseEstimator</code></li> <li><code>Clustering</code> class derives now from <code>sklearn.base.BaseEstimator</code> and <code>sklearn.base.BaseMixin</code></li> <li><code>fit_transform</code> and <code>transform</code>  method were added to <code>Similarity</code> class</li> <li><code>fit_predict</code> method was added to <code>Clustering</code> class</li> <li><code>score</code> method (for silhouette score) was added to <code>Clustering</code> class</li> <li>Added LGTM reports</li> <li>Allow to select the desired precision in the CI directly</li> <li>Improved clusters sorting algorithm to prefer larger clusters</li> <li><code>mode='kmedoids'</code> was added to CI</li> </ul>"},{"location":"changelog/#bugfix_2","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix bug of <code>load_clusters</code> in case of a single cluster</li> <li>Fix bug where <code>mode='kmedoids'</code> can not be executed with <code>n_clusters</code></li> <li>Fix bug for <code>mode='kmedoids'</code>, preventing masking diagonal</li> <li>Prevent interpolation in plot</li> <li>Enforce higher precision on storing correlation matrix to remove artifacts   of slight deviation from symmetry</li> </ul>"},{"location":"changelog/#other-changes_4","title":"Other changes:","text":"<ul> <li>Improved test functions of utils module</li> <li>Add more tests for clustering module</li> <li>Fixed some typos</li> <li>Improved README</li> </ul>"},{"location":"changelog/#022-2022-04-25","title":"0.2.2 - 2022-04-25","text":""},{"location":"changelog/#added-features-and-improvements_4","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Officially support python 3.10</li> </ul>"},{"location":"changelog/#other-changes_5","title":"Other changes:","text":"<ul> <li>Adding many helpful links to PyPI</li> <li>Remove dark-mode-only image from PyPI readme</li> <li>Add code coverage report via Codecov</li> </ul>"},{"location":"changelog/#021-2022-04-07","title":"0.2.1 - 2022-04-07","text":""},{"location":"changelog/#api-changes-warning_3","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Removed <code>n_iterations</code> parameter from <code>Clustering</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_5","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added clustering mode <code>mode='kmedoids'</code> for k-medoids clustering</li> <li>Added tools module to reopen clusters</li> </ul>"},{"location":"changelog/#other-changes_6","title":"Other changes:","text":"<ul> <li>Improved some test functions</li> </ul>"},{"location":"changelog/#020-2022-04-01","title":"0.2.0 - 2022-04-01","text":""},{"location":"changelog/#api-changes-warning_4","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Renamed cli script <code>mosaic</code>, former <code>MoSAIC</code></li> <li>Renamed package to <code>mosaic-clustering</code></li> <li>Renamed repository!!!</li> </ul>"},{"location":"changelog/#added-features-and-improvements_6","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added MoSAIC logo</li> <li>Added changelog</li> <li>Unified extra requirements of module, use <code>[all], [umap], [docs], [testing]</code> with pip</li> <li>Add toy matrix of paper and script to generate similar matrices</li> <li>Improve html of docs</li> <li>Improve README</li> </ul>"},{"location":"changelog/#bugfix_3","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix path of CLI script</li> <li>Fix coverage run</li> <li>Fix PEP 585 warnings by importing <code>typing</code> classes from <code>beartype.typing</code></li> <li>Reset <code>Clustering.labels_</code> on calling <code>CLustering.fit(...)</code></li> <li>Allow also numpy types, e.g., <code>np.float64</code>, or <code>np.int64</code> for resolution parameter</li> </ul>"},{"location":"changelog/#other-changes_7","title":"Other changes:","text":"<ul> <li>Increase required beartype version <code>0.8.1-&gt;0.10.4</code></li> <li>Rename <code>DistanceMatrix</code> to <code>SimilarityMatrix</code></li> <li>Fix example in <code>Clustering</code> to satisfy typing requirements</li> <li>Change import in <code>_typing.py</code> to non-private</li> <li>Improve some typings</li> <li>Require <code>typing_extensions</code> only for python &lt; 3.9</li> </ul>"},{"location":"changelog/#011-2022-01-24","title":"0.1.1 - 2022-01-24","text":""},{"location":"changelog/#added-features-and-improvements_7","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Add <code>labels_</code> attribute to <code>Clustering</code></li> </ul>"},{"location":"changelog/#bugfix_4","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Use <code>metric='precomputed'</code> for UMAP</li> <li>Relax check of symmetric input by using <code>np.allclose()</code></li> <li>Fix test expectation values</li> </ul>"},{"location":"changelog/#other-changes_8","title":"Other changes:","text":"<ul> <li>Catch warnings for umap</li> </ul>"},{"location":"changelog/#010-2021-12-09","title":"0.1.0 - 2021-12-09","text":"<ul> <li>Initial release</li> </ul>"},{"location":"contributing/","title":"Welcome to the <code>MoSAIC</code> Contributing Guide","text":"<p>This guide will give you an overview of the contribution workflow from opening an issue and creating a PR. To get an overview of the project, read the module overview.</p>"},{"location":"contributing/#issues","title":"Issues","text":""},{"location":"contributing/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a bug, want to request a new functionality, or have a question on how to use the module, please search if an issue already exists. If a related issue does not exist, feel free to open a new issue.</p>"},{"location":"contributing/#solve-an-issue","title":"Solve an issue","text":"<p>If you want to contribute and do not how, feel free to scan through the existing issues.</p>"},{"location":"contributing/#create-a-new-pull-request","title":"Create a new pull request","text":""},{"location":"contributing/#create-a-fork","title":"Create a fork","text":"<p>If you want to request a change, you first have to fork the repository.</p>"},{"location":"contributing/#setup-a-development-environment","title":"Setup a development environment","text":"bash + condabash + venvzsh + condazsh + venv <pre><code>conda create -n MoSAIC -c conda-forge python\nconda activate MoSAIC\npython -m pip install -e .[all]\n</code></pre> <pre><code>python -m venv ./MoSAIC\nsource ./MoSAIC/bin/activate\npython -m pip install -e .[all]\n</code></pre> <pre><code>conda create -n MoSAIC -c conda-forge python\nconda activate MoSAIC\npython -m pip install -e .\\[all]\n</code></pre> <pre><code>python -m venv ./MoSAIC\nsource ./MoSAIC/bin/activate\npython -m pip install -e .\\[all]\n</code></pre>"},{"location":"contributing/#make-changes-and-run-tests","title":"Make changes and run tests","text":"<p>Apply your changes and check if you followed the coding style (PEP8) by running <pre><code>python -m flake8 --config flake8-CI.cfg\n</code></pre> All errors pointing to <code>./build/</code> can be neglected.</p> <p>If you add a new function/method/class please ensure that you add a test function, as well. Running the test simply by <pre><code>pytest\n</code></pre> Ensure that the coverage does not decrease.</p>"},{"location":"contributing/#open-a-pull-request","title":"Open a pull request","text":"<p>Now you are ready to open a pull request and please do not forget to add a description.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#how-can-i-use-the-terminal-user-interface-tui","title":"How can I use the terminal user interface (TUI)?","text":"<p>This can be simply achieved by calling <code>python -m mosaic tui</code> or <code>mosaic tui</code>. It can be navigated via keyboard and mouse.</p>"},{"location":"faq/#how-to-load-the-clusters-file-back-to-python","title":"How to load the clusters file back to Python?","text":"<p>Simply use the function provided in <code>tools</code>: <pre><code>import mosaic\n\nclusterfile = '...'\nclusters = mosaic.tools.load_clusters(clusterfile)\n</code></pre></p>"},{"location":"faq/#is-it-possible-to-use-cross-validation-together-with-silhouette-score","title":"Is it possible to use cross validation together with silhouette score?","text":"<p>The new release <code>v0.3.0</code> refactored the classes, so that the <code>sklearn.model_selection.GridSearchCV</code> can be used. Check out the cv example.</p>"},{"location":"faq/#should-i-upgrade-the-package","title":"Should I upgrade the package?","text":"<p>You can check out the CHANGELOG.md to see what changed.</p>"},{"location":"faq/#how-can-i-interpretate-the-results","title":"How can I interpretate the results?","text":"<p>Check out our publication for two detailed examples.</p>"},{"location":"faq/#is-it-possible-to-install-the-cli-only","title":"Is it possible to install the CLI only?","text":"<p>Partially, yes. If you do not want to screw up your current Python environment there are multiples possibilities. Either create a virtual environment on your own via <code>conda</code> or <code>venv</code>, or you can simply use pipx</p>"},{"location":"faq/#is-the-silhouette-method-implemented","title":"Is the silhouette method implemented?","text":"<p>Yes, simply use the <code>score</code> method implemented in the <code>Clustering</code> class.</p>"},{"location":"faq/#i-want-to-use-the-umap-embedding","title":"I want to use the UMAP embedding!","text":"<p>This is still possible if you switch to the version 0.3.2. We removed that feature in newer versions.</p>"},{"location":"faq/#feature-x-is-missing","title":"Feature X is missing","text":"<p>If you believe that a crucial functionality/method is missing, feel free to open an issue and describe the missing functionality and why it should be added. Alternatively, you can implement it yourself and create a PR to add it to this package, see contributing guide.</p>"},{"location":"faq/#i-found-a-bug-what-to-do-next","title":"I found a bug. What to do next?","text":"<p>If you find a bug in this package, it is very kind of you to open an issue/bug report. This allows us to identify and fix the problem, thus improving the overall quality of the software for all users. By providing a clear and concise description of the problem, including steps to reproduce it, and relevant information such as device, operating system, and software version, you will help us resolve the problem quickly and effectively. Submitting a bug report is a valuable contribution to the software and its community, and is greatly appreciated by the development team.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2021 Biomolecular Dynamics</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"maintenance/","title":"Welcome to the <code>MoSAIC</code> Maintenance Guideline","text":"<p>This guide will give you an overview of how to publish a new version of MoSAIC. In the following we will refer to the new version as <code>v1.*.*</code>. This needs to be substituted to the current version, e.g. <code>v1.1.3</code>.</p>"},{"location":"maintenance/#prepare-new-release","title":"Prepare New Release","text":"<p>Please ensure that, 1. the version number in <code>setup.py</code> and <code>src/MoSAIC/__init__.py</code> are bumped, 1. a new tag is created via <code>git tag v1.*.*</code> and pushed <code>git push --tags</code>, and  1. the changelog includes the new tag and all changes of the release. As an example see for e.g. the commit of <code>v0.3.2</code>, <code>d43073</code>.</p>"},{"location":"maintenance/#build-and-upload-to-pypi","title":"Build and Upload to PyPI","text":"<p>For an introduction, please take a look at the PyPI manual.</p> <p>First ensure that all needed dependencies are installed <pre><code>python -m pip install --upgrade pip\npython -m pip install --upgrade build\npython -m pip install --upgrade twine\n</code></pre></p> <p>To create the build, please ensure first that the directory <code>dist</code> does not exist. Otherwise delete it, <pre><code>rm dist\n</code></pre> Then, execute <pre><code>python3 -m build\n</code></pre> which will create the directory <code>dist</code> including the source distributions: <pre><code>dist/\n\u251c\u2500\u2500 mosaic-clustering-1.*.*-py3-none-any.whl\n\u2514\u2500\u2500 mosaic-clustering-1.*.*.tar.gz\n</code></pre> To upload the new files, run <pre><code>python3 -m twine upload dist/*\n</code></pre></p>"},{"location":"maintenance/#update-on-conda-forge","title":"Update on Conda-Forge","text":"<p>Once a new version is published on PyPI, the conda-forge bot will automatically create a pull request on mosaic-clustering-feedstock.</p>"},{"location":"reference/","title":"mosaic","text":"<p>MoSAIC is an advanced Python package specifically designed for the analysis of discrete time series data from Molecular Dynamics (MD) simulations. It offers a wide range of capabilities to identify collective coordinates that describe the same biomolecular process.</p> <p>With MoSAIC, researchers and engineers can easily analyze large and complex datasets to gain insights into the underlying dynamics of biomolecular processes. The package provides the capability to calculate various similarity measures, such as linear correlation and mutual information, and to apply different clustering algorithms to find groups of coordinates which move in a concerted manner. By doing so, MoSAIC allows researchers and engineers to identify groups of coordinates that collectively describe the same process in MD simulations.</p> <p>MoSAIC can be used as a stand-alone analysis tool or as a preprocessing step for feature selection for subsequent Markov state modeling. It is structured into the following submodules:</p> <ul> <li> <p>similarity This submodule introduces a versatile class that enables the calculation of similarity measures based on different correlation metrics. Users can choose from a set of popular metrics, such as absolute value of Pearson correlation, of different normalizations of mutual information. The result is always a similarity matrix, which scales from 0 to 1. This submodule also supports efficient memory management and flexible normalization options for mutual information-based measures, making it a valuable addition to any data analysis pipeline.</p> </li> <li> <p>clustering This submodule is the most central component of MoSAIC that offers various techniques for analyzing similarity matrices. It provides different modes for clustering a correlation matrix, including the Leiden algorithm with different objective functions, linkage clustering, and k-medoids, and supports both weighted and unweighted, as well as full and sparse graphs. The resulting clusters and labels can be accessed through the attributes of the class.</p> </li> <li> <p>gridsearch This submodule provides a class for performing grid search cross validation. It allows users to explore different combinations of parameter settings for a clustering model and provides evaluation metrics for each combination. The best combination of parameters and the corresponding model can be easily retrieved using the provided attributes.</p> </li> <li> <p>utils This submodule provides utility functions that can be used to store and load the data or to provide runtume user information.</p> </li> </ul>"},{"location":"reference/#mosaic.Clustering","title":"<code>Clustering(*, mode='CPM', weighted=True, n_neighbors=None, resolution_parameter=None, n_clusters=None, seed=None)</code>","text":"<p>               Bases: <code>ClusterMixin</code>, <code>BaseEstimator</code></p> <p>Class for clustering a correlation matrix.</p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'CPM'</code> )           \u2013            <p>the mode which determines the quality function optimized by the Leiden algorithm ('CPM', or 'modularity') or linkage clustering. - 'CPM': will use the constant Potts model on the full, weighted graph - 'modularity': will use modularity on a knn-graph - 'linkage': will use complete-linkage clustering - 'kmedoids': will use k-medoids clustering</p> </li> <li> <code>weighted</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the underlying graph has weighted edges. Otherwise, the graph is constructed using the adjacency matrix.</p> </li> <li> <code>n_neighbors</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>This parameter specifies whether the whole matrix should be used, or a knn-graph, which reduces the required memory. The default depends on the <code>mode</code> - 'CPM': <code>None</code> uses the full graph, and - 'modularity': <code>None</code> uses square root of the number of features.</p> </li> <li> <code>resolution_parameter</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Required for mode 'CPM' and 'linkage'. If None, the resolution parameter will be set to the third quartile of <code>X</code> for <code>n_neighbors=None</code> and else to the mean value of the knn graph.</p> </li> <li> <code>n_clusters</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Required for 'kmedoids'. The number of medoids which will constitute the later clusters.</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Use an integer to make the randomness of Leidenalg deterministic. By default uses a random seed if nothing is specified.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>clusters_</code>               (<code>ndarray of shape (n_clusters, )</code>)           \u2013            <p>The result of the clustering process. A list of arrays, each containing all indices (features) corresponging to each cluster.</p> </li> <li> <code>labels_</code>               (<code>ndarray of shape (n_features, )</code>)           \u2013            <p>Labels of each feature.</p> </li> <li> <code>matrix_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>Permuted matrix according to the determined clusters.</p> </li> <li> <code>ticks_</code>               (<code>ndarray of shape (n_clusters, )</code>)           \u2013            <p>The cumulative number of features containing to the clusters. May be used as ticks for plotting <code>matrix_</code>.</p> </li> <li> <code>permutation_</code>               (<code>ndarray of shape (n_features, )</code>)           \u2013            <p>Permutation of the input features (corresponds to flattened <code>clusters_</code>).</p> </li> <li> <code>n_neighbors_</code>               (<code>int</code>)           \u2013            <p>Only avaiable when using knn graph. Indicates the number of nearest neighbors used for constructin the knn-graph.</p> </li> <li> <code>resolution_param_</code>               (<code>float</code>)           \u2013            <p>Only for mode 'CPM' and 'linkage'. Indicates the resolution parameter used for the CPM based Leiden clustering.</p> </li> <li> <code>linkage_matrix_</code>               (<code>ndarray of shape (n_clusters - 1, 4)</code>)           \u2013            <p>Only for mode 'linkage'. Contains the hierarchical clustering encoded as a linkage matrix, see scipy:spatial.distance.linkage.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import mosaic\n&gt;&gt;&gt; mat = np.array([[1.0, 0.1, 0.9], [0.1, 1.0, 0.1], [0.9, 0.1, 1.0]])\n&gt;&gt;&gt; clust = mosaic.Clustering()\n&gt;&gt;&gt; clust.fit(mat)\nClustering(resolution_parameter=0.7)\n&gt;&gt;&gt; clust.matrix_\narray([[1. , 0.9, 0.1],\n       [0.9, 1. , 0.1],\n       [0.1, 0.1, 1. ]])\n&gt;&gt;&gt; clust.clusters_\narray([list([2, 0]), list([1])], dtype=object)\n</code></pre> <p>Initialize Clustering class.</p> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    mode: ClusteringModeString = 'CPM',\n    weighted: bool = True,\n    n_neighbors: Optional[PositiveInt] = None,\n    resolution_parameter: Optional[NumInRange0to1] = None,\n    n_clusters: Optional[PositiveInt] = None,\n    seed: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Initialize Clustering class.\"\"\"\n    self.mode: ClusteringModeString = mode\n    self.n_clusters: Optional[PositiveInt] = n_clusters\n    self.n_neighbors: Optional[PositiveInt] = n_neighbors\n    self.resolution_parameter: Optional[NumInRange0to1] = (\n        resolution_parameter\n    )\n    self.seed: Optional[int] = seed\n    self.weighted: bool = weighted\n\n    if mode in {'linkage', 'kmedoids'} and self.n_neighbors is not None:\n        raise NotImplementedError(\n            f\"mode='{mode}' does not support knn-graphs.\",\n        )\n\n    if mode == 'kmedoids':\n        warnings.warn(\n            \"The 'kmedoids' mode is deprecated and will be removed in a \"\n            \"future release.\",\n            DeprecationWarning,\n            stacklevel=2\n        )\n        if self.n_clusters is None:\n            raise TypeError(\n                f\"mode='{mode}' needs parameter 'n_clusters'\",\n            )\n    elif mode != 'kmedoids' and self.n_clusters is not None:\n        raise NotImplementedError(\n            f\"mode='{mode}' does not support the usage of 'n_clusters'\",\n        )\n\n    if mode in {'CPM', 'linkage'}:\n        if not weighted:\n            raise NotImplementedError(\n                f\"mode='{mode}' does not support weighted=False\",\n            )\n    elif resolution_parameter is not None:\n        raise NotImplementedError(\n            f\"mode='{mode}' does not support the usage of the \"\n            'resolution_parameter',\n        )\n</code></pre>"},{"location":"reference/#mosaic.Clustering.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Clusters the correlation matrix by Leiden clustering on a graph.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>Matrix containing the correlation metric which is clustered. The values should go from [0, 1] where 1 means completely correlated and 0 no correlation.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef fit(self, X: SimilarityMatrix, y: Optional[np.ndarray] = None):\n    \"\"\"Clusters the correlation matrix by Leiden clustering on a graph.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_features, n_features)\n        Matrix containing the correlation metric which is clustered. The\n        values should go from [0, 1] where 1 means completely correlated\n        and 0 no correlation.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    self._reset()\n\n    # prepare matric for graph construction\n    mat: FloatMatrix\n    if self.mode in {'linkage', 'kmedoids'}:\n        mat = np.copy(X)\n    elif self.mode == 'CPM' and self.n_neighbors is None:\n        mat = np.copy(X)\n    else:\n        mat = self._construct_knn_mat(X)\n\n    if self.mode in {'CPM', 'linkage'}:\n        # mask diagonal and zero elements\n        mat[mat == 0] = np.nan\n        mat[np.diag_indices_from(mat)] = np.nan\n\n        if self.resolution_parameter is None:\n            if self.n_neighbors is None:\n                third_quartile = 0.75\n                self.resolution_parameter = np.nanquantile(\n                    mat, third_quartile,\n                )\n            else:\n                self.resolution_parameter = np.nanmean(mat)\n\n        self.resolution_param_: NumInRange0to1 = (\n            self.resolution_parameter\n        )\n\n    # create graph\n    mat[np.isnan(mat)] = 0\n\n    clusters: Object1DArray\n    if self.mode == 'linkage':\n        clusters = self._clustering_linkage(mat)\n    elif self.mode == 'kmedoids':\n        clusters = self._clustering_kmedoids(mat)\n    else:  # _mode in {'CPM', 'modularity'}\n        graph: ig.Graph = ig.Graph.Weighted_Adjacency(\n            list(mat.astype(np.float64)), loops=False,\n        )\n        clusters = self._clustering_leiden(graph)\n\n    self.clusters_: Object1DArray = _sort_clusters(clusters, X)\n    self.permutation_: Index1DArray = np.hstack(self.clusters_)\n    self.matrix_: Float2DArray = np.copy(X)[\n        np.ix_(self.permutation_, self.permutation_)\n    ]\n    self.ticks_: Index1DArray = np.cumsum(\n        [len(cluster) for cluster in self.clusters_],\n    )\n    labels: Index1DArray = np.empty_like(self.permutation_)\n    for idx, cluster in enumerate(self.clusters_):\n        labels[cluster] = idx\n    self.labels_: Index1DArray = labels\n\n    return self\n</code></pre>"},{"location":"reference/#mosaic.Clustering.fit_predict","title":"<code>fit_predict(X, y=None)</code>","text":"<p>Clusters the correlation matrix by Leiden clustering on a graph.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>Matrix containing the correlation metric which is clustered. The values should go from [0, 1] where 1 means completely correlated and 0 no correlation.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>labels</code> (              <code>ndarray of shape (n_samples,)</code> )          \u2013            <p>Cluster labels.</p> </li> </ul> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef fit_predict(\n    self, X: SimilarityMatrix, y: Optional[np.ndarray] = None,\n) -&gt; Index1DArray:\n    \"\"\"Clusters the correlation matrix by Leiden clustering on a graph.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_features, n_features)\n        Matrix containing the correlation metric which is clustered. The\n        values should go from [0, 1] where 1 means completely correlated\n        and 0 no correlation.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    labels : ndarray of shape (n_samples,)\n        Cluster labels.\n\n    \"\"\"\n    return super().fit_predict(X, y)\n</code></pre>"},{"location":"reference/#mosaic.Clustering.score","title":"<code>score(X, y=None, sample_weight=None)</code>","text":"<p>Estimate silhouette_score of new correlation matrix.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>New matrix containing the correlation metric to score. The values should go from [0, 1] where 1 means completely correlated and 0 no correlation.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> <li> <code>sample_weight</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>score</code> (              <code>float</code> )          \u2013            <p>Silhouette score of new correlation matrix based on fitted labels.</p> </li> </ul> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef score(\n    self,\n    X: SimilarityMatrix,\n    y: Optional[np.ndarray] = None,\n    sample_weight: Optional[np.ndarray] = None,\n) -&gt; Float:\n    \"\"\"Estimate silhouette_score of new correlation matrix.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_features, n_features)\n        New matrix containing the correlation metric to score. The\n        values should go from [0, 1] where 1 means completely correlated\n        and 0 no correlation.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n    sample_weight: Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    score : float\n        Silhouette score of new correlation matrix based on fitted labels.\n\n    \"\"\"\n    check_is_fitted(self, attributes=['labels_', 'matrix_'])\n\n    n_labels = len(self.labels_)\n    n_unique_labels = len(np.unique(self.labels_))\n\n    if n_labels != len(X):\n        raise ValueError(\n            f'Dimension of X d={len(X):.0f} needs to agree with the '\n            f'dimension of the fitted data d={n_labels:.0f}.',\n        )\n\n    if n_unique_labels in {1, n_labels}:\n        return -1.0\n    return silhouette_score(X, labels=self.labels_)\n</code></pre>"},{"location":"reference/#mosaic.GridSearchCV","title":"<code>GridSearchCV(*, similarity, clustering, param_grid, gridsearch_kwargs={})</code>","text":"<p>               Bases: <code>GridSearchCV</code></p> <p>Class for grid search cross validation.</p> <p>Parameters:</p> <ul> <li> <code>similarity</code>               (<code>Similarity</code>)           \u2013            <p>Similarity instance setup with constant parameters, see <code>mosaic.Similarity</code> for available parameters. <code>low_memory</code> is not supported.</p> </li> <li> <code>clustering</code>               (<code>Clustering</code>)           \u2013            <p>Clustering instance setup with constant parameters, see <code>mosaic.Clustering</code> for available parameters.</p> </li> <li> <code>param_grid</code>               (<code>dict</code>)           \u2013            <p>Dictionary with parameters names (<code>str</code>) as keys and lists of parameter settings to try as values, or list of such dictionaries, in which case the grids spanned by each dictionary in the list are explored.</p> </li> <li> <code>gridsearch_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Dictionary with parameters to be used for <code>sklearn.model_selection.GridSearchCV</code> class. The parameter <code>estimator</code> is not supported and <code>param_grid</code> needs to be passed directly to the class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cv_results_</code>               (<code>dict of numpy (masked) ndarrays</code>)           \u2013            <p>A dict with keys as column headers and values as columns.</p> </li> <li> <code>best_estimator_</code>               (<code>estimator</code>)           \u2013            <p>Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data.</p> </li> <li> <code>best_score_</code>               (<code>float</code>)           \u2013            <p>Mean cross-validated score of the best_estimator.</p> </li> <li> <code>best_params_</code>               (<code>dict</code>)           \u2013            <p>Parameter setting that gave the best results on the hold out data.</p> </li> <li> <code>best_index_</code>               (<code>int</code>)           \u2013            <p>The index (of the <code>cv_results_</code> arrays) which corresponds to the best candidate parameter setting.</p> </li> <li> <code>n_splits_</code>               (<code>int</code>)           \u2013            <p>The number of cross-validation splits (folds/iterations).</p> </li> </ul> Notes <p>Check out sklearn.model_selection.GridSearchCV for an overview of all available attributes and more detailed description.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import mosaic\n&gt;&gt;&gt; # create two correlated data sets\n&gt;&gt;&gt; traj = np.array([\n...     func(np.linspace(0, 20, 1000))\n...     for  func in (\n...         np.sin,\n...         lambda x: np.sin(x + 0.1),\n...         np.cos,\n...         lambda x: np.cos(x + 0.1),\n...     )\n... ]).T\n&gt;&gt;&gt; search = mosaic.GridSearchCV(\n...     similarity=mosaic.Similarity(),\n...     clustering=mosaic.Clustering(),\n...     param_grid={'resolution_parameter': [0.05, 0.2]},\n... )\n&gt;&gt;&gt; search.fit(traj)\nGridSearchCV(clustering=Clustering(),\n             param_grid={'clust__resolution_parameter': [0.05, 0.2]},\n             similarity=Similarity())\n&gt;&gt;&gt; search.best_params_\n{'clust__resolution_parameter': 0.2}\n&gt;&gt;&gt; search.best_estimator_\nPipeline(steps=[('sim', Similarity()),\n                ('clust', Clustering(resolution_parameter=0.2))])\n</code></pre> <p>Initialize GridSearchCV class.</p> Source code in <code>src/mosaic/gridsearch.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    similarity: Similarity,\n    clustering: Clustering,\n    param_grid: Dict,\n    gridsearch_kwargs: Dict = {},\n) -&gt; None:\n    \"\"\"Initialize GridSearchCV class.\"\"\"\n    self.similarity: Similarity = similarity\n    self.clustering: Clustering = clustering\n    self.gridsearch_kwargs: Dict = gridsearch_kwargs\n\n    if 'estimator' in self.gridsearch_kwargs:\n        raise NotImplementedError(\n            'Custom estimators are not supported. Please use the '\n            'sklearn class GirdSearchCV directly.',\n        )\n\n    if 'param_grid' in self.gridsearch_kwargs:\n        raise NotImplementedError(\n            \"Please pass 'param_grid' directly to the the class.\",\n        )\n\n    if similarity.get_params()['low_memory']:\n        raise NotImplementedError(\n            \"'low_memory' is currently not implemented.\",\n        )\n\n    if not param_grid:\n        raise ValueError(\n            'At least a single parameter needs to be provided',\n        )\n\n    self.pipeline = Pipeline([\n        (self._sim_prefix, self.similarity),\n        (self._clust_prefix, self.clustering),\n    ])\n\n    self.param_grid: Dict = {}\n    for param, values in param_grid.items():\n        if param in similarity.get_params():\n            self.param_grid[\n                f'{self._sim_prefix}__{param}'\n            ] = values\n        elif param in clustering.get_params():\n            self.param_grid[\n                f'{self._clust_prefix}__{param}'\n            ] = values\n            print('######################', self.param_grid)\n        else:\n            raise ValueError(\n                f\"param_grid key '{param}' is not available.\"\n            )\n\n    super().__init__(\n        estimator=self.pipeline,\n        param_grid=self.param_grid,\n        **self.gridsearch_kwargs,\n    )\n</code></pre>"},{"location":"reference/#mosaic.GridSearchCV.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Clusters the correlation matrix by Leiden clustering on a graph.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features)</code>)           \u2013            <p>Training vector, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/mosaic/gridsearch.py</code> <pre><code>@beartype\ndef fit(\n    self,\n    X: FloatMax2DArray,\n    y: Optional[np.ndarray] = None,\n):\n    \"\"\"Clusters the correlation matrix by Leiden clustering on a graph.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features)\n        Training vector, where `n_samples` is the number of samples and\n        `n_features` is the number of features.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    return super().fit(X)\n</code></pre>"},{"location":"reference/#mosaic.Similarity","title":"<code>Similarity(*, metric='correlation', low_memory=False, normalize_method=None, use_knn_estimator=False)</code>","text":"<p>               Bases: <code>BaseEstimator</code></p> <p>Class for calculating the similarity measure.</p> <p>Parameters:</p> <ul> <li> <code>metric</code>               (<code>str</code>, default:                   <code>'correlation'</code> )           \u2013            <p>the correlation metric to use for the feature distance matrix. - <code>'correlation'</code> will use the absolute value of the Pearson   correlation - <code>'NMI'</code> will use the mutual information normalized by joined entropy - <code>'GY'</code> uses Gel'fand and Yaglom normalization[^1] - <code>'JSD'</code> will use the Jensen-Shannon divergence between the joint   probability distribution and the product of the marginal probability   distributions to calculate their dissimilarity Note: <code>'NMI'</code> is supported only with low_memory=False</p> </li> <li> <code>low_memory</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the input of fit X needs to be a file name and the correlation is calculated on the fly. Otherwise, an array is assumed as input X.</p> </li> <li> <code>normalize_method</code>               (<code>str</code>, default:                   <code>'geometric'</code> )           \u2013            <p>Only required for metric <code>'NMI'</code>. Determines the normalization factor for the mutual information: - <code>'joint'</code> is the joint entropy - <code>'max'</code> is the maximum of the individual entropies - <code>'arithmetic'</code> is the mean of the individual entropies - <code>'geometric'</code> is the square root of the product of the individual   entropies - <code>'min'</code> is the minimum of the individual entropies</p> </li> <li> <code>use_knn_estimator</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Can only be set for metric GY. If True, the mutual information is estimated reliably by a parameter free method based on entropy estimation from k-nearest neighbors distances[^3]. It considerably increases the computational time and is thus only advisable for relatively small data-sets.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>matrix_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The correlation-measure-based pairwise distance matrix of the data. It scales from [0, 1].</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import mosaic\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; data = np.array([np.cos(x), np.cos(x + np.pi / 6)]).T\n&gt;&gt;&gt; sim = mosaic.Similarity()\n&gt;&gt;&gt; sim.fit(data)\nSimilarity()\n&gt;&gt;&gt; sim.matrix_\narray([[1.       , 0.9697832],\n       [0.9697832, 1.       ]])\n</code></pre> Notes <p>The Pearson correlation coefficient is defined as</p> \\[\\rho_{X,Y} = \\frac{\\langle(X -\\mu_X)(Y -\\mu_Y)\\rangle}{\\sigma_X\\sigma_Y}.\\] <p>For the online (low memory) option the Welford algorithm<sup>2</sup> is used.</p> <p>The Jensen-Shannon divergence is defined as</p> \\[D_{\\text{JS}} = \\frac{1}{2} D_{\\text{KL}}(p(x,y)||M) + \\frac{1}{2} D_{\\text{KL}}(p(x)p(y)||M)\\;,\\] <p>where \\(M = \\frac{1}{2} [p(x,y) + p(x)p(y)]\\) is an averaged probability distribution and \\(D_{\\text{KL}}\\) denotes the Kullback-Leibler divergence.</p> <ol> <li> <p>Gel'fand, I.M. and Yaglom, A.M. (1957). \"Calculation of amount of information about a random function contained in another such function\". American Mathematical Society Translations, series 2, 12, pp. 199\u2013246.\u00a0\u21a9</p> </li> <li> <p>Welford algorithm, generalized to correlation. Taken from: Donald E. Knuth (1998). \"The Art of Computer Programming\", volume 2: Seminumerical Algorithms, 3<sup>rd</sup> edn., p. 232. Boston: Addison-Wesley.\u00a0\u21a9</p> </li> <li> <p>B.C. Ross, PLoS ONE 9(2) (2014), \"Mutual Information between Discrete and Continuous Data Sets\"\u00a0\u21a9</p> </li> </ol> <p>Initialize Similarity class.</p> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    metric: MetricString = 'correlation',\n    low_memory: bool = False,\n    normalize_method: Optional[NormString] = None,\n    use_knn_estimator: bool = False,\n):\n    \"\"\"Initialize Similarity class.\"\"\"\n    self.metric: MetricString = metric\n    self.low_memory: bool = low_memory\n    self.use_knn_estimator: bool = use_knn_estimator\n    if self.metric == 'NMI':\n        if normalize_method is None:\n            normalize_method = self._default_normalize_method\n    elif normalize_method is not None:\n        raise NotImplementedError(\n            'Normalize methods are only supported with metric=\"NMI\"',\n        )\n    self.normalize_method: NormString = normalize_method\n    if self.metric != 'GY' and self.use_knn_estimator:\n        raise NotImplementedError(\n            (\n                'The mutual information estimate based on k-nearest'\n                'neighbors distances is only supported with metric=\"GY\"'\n            ),\n        )\n</code></pre>"},{"location":"reference/#mosaic.Similarity.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Compute the correlation/nmi distance matrix.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@singledispatchmethod\n@beartype\ndef fit(\n    self,\n    X: Union[FloatMax2DArray, str],\n    y: Optional[ArrayLikeFloat] = None,\n):\n    \"\"\"Compute the correlation/nmi distance matrix.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    raise NotImplementedError('Fatal error, this should never be reached.')\n</code></pre>"},{"location":"reference/#mosaic.Similarity.fit_transform","title":"<code>fit_transform(X, y=None)</code>","text":"<p>Compute the correlation/nmi distance matrix and returns it.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Similarity</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>Similarity matrix.</p> </li> </ul> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@beartype\ndef fit_transform(\n    self,\n    X: Union[FloatMax2DArray, str],\n    y: Optional[ArrayLikeFloat] = None,\n) -&gt; FloatMatrix:\n    \"\"\"Compute the correlation/nmi distance matrix and returns it.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    Similarity : ndarray of shape (n_features, n_features)\n        Similarity matrix.\n\n    \"\"\"\n    self.fit(X)\n    return self.matrix_\n</code></pre>"},{"location":"reference/#mosaic.Similarity.transform","title":"<code>transform(X)</code>","text":"<p>Compute the correlation/nmi distance matrix and returns it.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Similarity</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>Similarity matrix.</p> </li> </ul> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@beartype\ndef transform(\n    self,\n    X: Union[FloatMax2DArray, str],\n) -&gt; FloatMatrix:\n    \"\"\"Compute the correlation/nmi distance matrix and returns it.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n\n    Returns\n    -------\n    Similarity : ndarray of shape (n_features, n_features)\n        Similarity matrix.\n\n    \"\"\"\n    return self.fit_transform(X)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mosaic<ul> <li>clustering</li> <li>gridsearch</li> <li>similarity</li> <li>utils</li> </ul> </li> <li>cli</li> </ul>"},{"location":"reference/cli/","title":"mosaic","text":"<p>MoSAIC motion v0.4.1</p> <p>Molecular systems automated identification of collective motion, is a correlation based feature selection framework for MD data. Copyright \u00a9 2021-2022, Georg Diez and Daniel Nagel</p> <p>Usage:</p> <pre><code>mosaic [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>clustering: Clustering similarity matrix of coordinates.</li> <li>similarity: Creating similarity matrix of coordinates.</li> <li>tui: Open Textual TUI for interactive usage.</li> </ul>"},{"location":"reference/cli/#mosaic-clustering","title":"mosaic clustering","text":"<p>Clustering similarity matrix of coordinates.</p> <p>Usage:</p> <pre><code>mosaic clustering [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --mode [linkage|modularity|kmedoids|CPM]\n                                  Mode used for Leiden clustering.  [default:\n                                  CPM]\n  --n-neighbors INTEGER RANGE     If unequal to None, a knn-graph will be\n                                  used. If None, for mode \"CPM\" the whole\n                                  matrix is used, while for \"modularity\" the\n                                  sqrt(n_features)  [x&gt;=2]\n  --resolution-parameter FLOAT RANGE\n                                  Resolution parameter used for CPM.\n                                  [0&lt;=x&lt;=1]\n  --n-clusters INTEGER RANGE      Required for mode=\"kmedoids\". The number of\n                                  clusters to form.  [x&gt;=2]\n  -i, --input PATH                Path to input file. Needs to be of shape\n                                  (n_features, n_features).  [required]\n  -o, --output-basename PATH      Basename of output files.\n  --weighted / --unweighted       Using an adjacency graph (not supported for\n                                  CPM).  [default: weighted]\n  --plot                          Plotting matrix.\n  -n, --name PATH                 Path to file containing names of each colum.\n                                  Needs to be of shape (n_features, ).\n  --precision [half|single|double]\n                                  Precision used for calculation. Lower\n                                  precision reduces memory impact but may lead\n                                  to overflow errors.  [default: single]\n  -v, --verbose                   Activate verbose mode.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#mosaic-similarity","title":"mosaic similarity","text":"<p>Creating similarity matrix of coordinates.</p> <p>Usage:</p> <pre><code>mosaic similarity [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --metric [GY|JSD|NMI|correlation]\n                                  Metric used to estimate similarity measure\n                                  matrix.  [default: correlation]\n  --normalize-method [max|arithmetic|joint|min|geometric]\n                                  Only required for metric=\"NMI\". Determines\n                                  the normalization factor for the mutual\n                                  information. See docs for help.\n  --low-memory                    If set the correlation is calculated on-the-\n                                  fly using the online Welford algorithm. This\n                                  is much slower but needs less RAM and is\n                                  preferable for larger files. This supports\n                                  only metric=correlation.\n  -i, --input PATH                Path to input file. Needs to be of shape\n                                  (n_samples, n_features). All command lines\n                                  need to start with \"#\". By default\n                                  np.float16 is used for the datatype.\n                                  [required]\n  -o, --output PATH               Path to output file. Will be a matrix of\n                                  shape (n_features, n_features).  [required]\n  --knn_estimator                 Uses a parameter free estimate for the\n                                  Gelfand-Yaglom mutualinformation based\n                                  distance measure which yields more\n                                  accurateresults, but is computationally more\n                                  expensive.\n  --precision [half|single|double]\n                                  Precision used for calculation. Lower\n                                  precision reduces memory impact but may lead\n                                  to overflow errors.  [default: single]\n  -v, --verbose                   Activate verbose mode.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#mosaic-tui","title":"mosaic tui","text":"<p>Open Textual TUI for interactive usage.</p> <p>Usage:</p> <pre><code>mosaic tui [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"reference/clustering/","title":"clustering","text":"<p>Class for clustering the correlation matrices.</p> <p>MIT License Copyright \u00a9 2021-2024, Daniel Nagel, Georg Diez All rights reserved.</p>"},{"location":"reference/clustering/#mosaic.clustering.Clustering","title":"<code>Clustering(*, mode='CPM', weighted=True, n_neighbors=None, resolution_parameter=None, n_clusters=None, seed=None)</code>","text":"<p>               Bases: <code>ClusterMixin</code>, <code>BaseEstimator</code></p> <p>Class for clustering a correlation matrix.</p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'CPM'</code> )           \u2013            <p>the mode which determines the quality function optimized by the Leiden algorithm ('CPM', or 'modularity') or linkage clustering. - 'CPM': will use the constant Potts model on the full, weighted graph - 'modularity': will use modularity on a knn-graph - 'linkage': will use complete-linkage clustering - 'kmedoids': will use k-medoids clustering</p> </li> <li> <code>weighted</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the underlying graph has weighted edges. Otherwise, the graph is constructed using the adjacency matrix.</p> </li> <li> <code>n_neighbors</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>This parameter specifies whether the whole matrix should be used, or a knn-graph, which reduces the required memory. The default depends on the <code>mode</code> - 'CPM': <code>None</code> uses the full graph, and - 'modularity': <code>None</code> uses square root of the number of features.</p> </li> <li> <code>resolution_parameter</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Required for mode 'CPM' and 'linkage'. If None, the resolution parameter will be set to the third quartile of <code>X</code> for <code>n_neighbors=None</code> and else to the mean value of the knn graph.</p> </li> <li> <code>n_clusters</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Required for 'kmedoids'. The number of medoids which will constitute the later clusters.</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Use an integer to make the randomness of Leidenalg deterministic. By default uses a random seed if nothing is specified.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>clusters_</code>               (<code>ndarray of shape (n_clusters, )</code>)           \u2013            <p>The result of the clustering process. A list of arrays, each containing all indices (features) corresponging to each cluster.</p> </li> <li> <code>labels_</code>               (<code>ndarray of shape (n_features, )</code>)           \u2013            <p>Labels of each feature.</p> </li> <li> <code>matrix_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>Permuted matrix according to the determined clusters.</p> </li> <li> <code>ticks_</code>               (<code>ndarray of shape (n_clusters, )</code>)           \u2013            <p>The cumulative number of features containing to the clusters. May be used as ticks for plotting <code>matrix_</code>.</p> </li> <li> <code>permutation_</code>               (<code>ndarray of shape (n_features, )</code>)           \u2013            <p>Permutation of the input features (corresponds to flattened <code>clusters_</code>).</p> </li> <li> <code>n_neighbors_</code>               (<code>int</code>)           \u2013            <p>Only avaiable when using knn graph. Indicates the number of nearest neighbors used for constructin the knn-graph.</p> </li> <li> <code>resolution_param_</code>               (<code>float</code>)           \u2013            <p>Only for mode 'CPM' and 'linkage'. Indicates the resolution parameter used for the CPM based Leiden clustering.</p> </li> <li> <code>linkage_matrix_</code>               (<code>ndarray of shape (n_clusters - 1, 4)</code>)           \u2013            <p>Only for mode 'linkage'. Contains the hierarchical clustering encoded as a linkage matrix, see scipy:spatial.distance.linkage.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import mosaic\n&gt;&gt;&gt; mat = np.array([[1.0, 0.1, 0.9], [0.1, 1.0, 0.1], [0.9, 0.1, 1.0]])\n&gt;&gt;&gt; clust = mosaic.Clustering()\n&gt;&gt;&gt; clust.fit(mat)\nClustering(resolution_parameter=0.7)\n&gt;&gt;&gt; clust.matrix_\narray([[1. , 0.9, 0.1],\n       [0.9, 1. , 0.1],\n       [0.1, 0.1, 1. ]])\n&gt;&gt;&gt; clust.clusters_\narray([list([2, 0]), list([1])], dtype=object)\n</code></pre> <p>Initialize Clustering class.</p> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    mode: ClusteringModeString = 'CPM',\n    weighted: bool = True,\n    n_neighbors: Optional[PositiveInt] = None,\n    resolution_parameter: Optional[NumInRange0to1] = None,\n    n_clusters: Optional[PositiveInt] = None,\n    seed: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Initialize Clustering class.\"\"\"\n    self.mode: ClusteringModeString = mode\n    self.n_clusters: Optional[PositiveInt] = n_clusters\n    self.n_neighbors: Optional[PositiveInt] = n_neighbors\n    self.resolution_parameter: Optional[NumInRange0to1] = (\n        resolution_parameter\n    )\n    self.seed: Optional[int] = seed\n    self.weighted: bool = weighted\n\n    if mode in {'linkage', 'kmedoids'} and self.n_neighbors is not None:\n        raise NotImplementedError(\n            f\"mode='{mode}' does not support knn-graphs.\",\n        )\n\n    if mode == 'kmedoids':\n        warnings.warn(\n            \"The 'kmedoids' mode is deprecated and will be removed in a \"\n            \"future release.\",\n            DeprecationWarning,\n            stacklevel=2\n        )\n        if self.n_clusters is None:\n            raise TypeError(\n                f\"mode='{mode}' needs parameter 'n_clusters'\",\n            )\n    elif mode != 'kmedoids' and self.n_clusters is not None:\n        raise NotImplementedError(\n            f\"mode='{mode}' does not support the usage of 'n_clusters'\",\n        )\n\n    if mode in {'CPM', 'linkage'}:\n        if not weighted:\n            raise NotImplementedError(\n                f\"mode='{mode}' does not support weighted=False\",\n            )\n    elif resolution_parameter is not None:\n        raise NotImplementedError(\n            f\"mode='{mode}' does not support the usage of the \"\n            'resolution_parameter',\n        )\n</code></pre>"},{"location":"reference/clustering/#mosaic.clustering.Clustering.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Clusters the correlation matrix by Leiden clustering on a graph.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>Matrix containing the correlation metric which is clustered. The values should go from [0, 1] where 1 means completely correlated and 0 no correlation.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef fit(self, X: SimilarityMatrix, y: Optional[np.ndarray] = None):\n    \"\"\"Clusters the correlation matrix by Leiden clustering on a graph.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_features, n_features)\n        Matrix containing the correlation metric which is clustered. The\n        values should go from [0, 1] where 1 means completely correlated\n        and 0 no correlation.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    self._reset()\n\n    # prepare matric for graph construction\n    mat: FloatMatrix\n    if self.mode in {'linkage', 'kmedoids'}:\n        mat = np.copy(X)\n    elif self.mode == 'CPM' and self.n_neighbors is None:\n        mat = np.copy(X)\n    else:\n        mat = self._construct_knn_mat(X)\n\n    if self.mode in {'CPM', 'linkage'}:\n        # mask diagonal and zero elements\n        mat[mat == 0] = np.nan\n        mat[np.diag_indices_from(mat)] = np.nan\n\n        if self.resolution_parameter is None:\n            if self.n_neighbors is None:\n                third_quartile = 0.75\n                self.resolution_parameter = np.nanquantile(\n                    mat, third_quartile,\n                )\n            else:\n                self.resolution_parameter = np.nanmean(mat)\n\n        self.resolution_param_: NumInRange0to1 = (\n            self.resolution_parameter\n        )\n\n    # create graph\n    mat[np.isnan(mat)] = 0\n\n    clusters: Object1DArray\n    if self.mode == 'linkage':\n        clusters = self._clustering_linkage(mat)\n    elif self.mode == 'kmedoids':\n        clusters = self._clustering_kmedoids(mat)\n    else:  # _mode in {'CPM', 'modularity'}\n        graph: ig.Graph = ig.Graph.Weighted_Adjacency(\n            list(mat.astype(np.float64)), loops=False,\n        )\n        clusters = self._clustering_leiden(graph)\n\n    self.clusters_: Object1DArray = _sort_clusters(clusters, X)\n    self.permutation_: Index1DArray = np.hstack(self.clusters_)\n    self.matrix_: Float2DArray = np.copy(X)[\n        np.ix_(self.permutation_, self.permutation_)\n    ]\n    self.ticks_: Index1DArray = np.cumsum(\n        [len(cluster) for cluster in self.clusters_],\n    )\n    labels: Index1DArray = np.empty_like(self.permutation_)\n    for idx, cluster in enumerate(self.clusters_):\n        labels[cluster] = idx\n    self.labels_: Index1DArray = labels\n\n    return self\n</code></pre>"},{"location":"reference/clustering/#mosaic.clustering.Clustering.fit_predict","title":"<code>fit_predict(X, y=None)</code>","text":"<p>Clusters the correlation matrix by Leiden clustering on a graph.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>Matrix containing the correlation metric which is clustered. The values should go from [0, 1] where 1 means completely correlated and 0 no correlation.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>labels</code> (              <code>ndarray of shape (n_samples,)</code> )          \u2013            <p>Cluster labels.</p> </li> </ul> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef fit_predict(\n    self, X: SimilarityMatrix, y: Optional[np.ndarray] = None,\n) -&gt; Index1DArray:\n    \"\"\"Clusters the correlation matrix by Leiden clustering on a graph.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_features, n_features)\n        Matrix containing the correlation metric which is clustered. The\n        values should go from [0, 1] where 1 means completely correlated\n        and 0 no correlation.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    labels : ndarray of shape (n_samples,)\n        Cluster labels.\n\n    \"\"\"\n    return super().fit_predict(X, y)\n</code></pre>"},{"location":"reference/clustering/#mosaic.clustering.Clustering.score","title":"<code>score(X, y=None, sample_weight=None)</code>","text":"<p>Estimate silhouette_score of new correlation matrix.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>New matrix containing the correlation metric to score. The values should go from [0, 1] where 1 means completely correlated and 0 no correlation.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> <li> <code>sample_weight</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>score</code> (              <code>float</code> )          \u2013            <p>Silhouette score of new correlation matrix based on fitted labels.</p> </li> </ul> Source code in <code>src/mosaic/clustering.py</code> <pre><code>@beartype\ndef score(\n    self,\n    X: SimilarityMatrix,\n    y: Optional[np.ndarray] = None,\n    sample_weight: Optional[np.ndarray] = None,\n) -&gt; Float:\n    \"\"\"Estimate silhouette_score of new correlation matrix.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_features, n_features)\n        New matrix containing the correlation metric to score. The\n        values should go from [0, 1] where 1 means completely correlated\n        and 0 no correlation.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n    sample_weight: Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    score : float\n        Silhouette score of new correlation matrix based on fitted labels.\n\n    \"\"\"\n    check_is_fitted(self, attributes=['labels_', 'matrix_'])\n\n    n_labels = len(self.labels_)\n    n_unique_labels = len(np.unique(self.labels_))\n\n    if n_labels != len(X):\n        raise ValueError(\n            f'Dimension of X d={len(X):.0f} needs to agree with the '\n            f'dimension of the fitted data d={n_labels:.0f}.',\n        )\n\n    if n_unique_labels in {1, n_labels}:\n        return -1.0\n    return silhouette_score(X, labels=self.labels_)\n</code></pre>"},{"location":"reference/gridsearch/","title":"gridsearch","text":"<p>Class for GridSearchCV with silhouette score.</p> <p>MIT License Copyright \u00a9 2021-2022, Daniel Nagel All rights reserved.</p>"},{"location":"reference/gridsearch/#mosaic.gridsearch.GridSearchCV","title":"<code>GridSearchCV(*, similarity, clustering, param_grid, gridsearch_kwargs={})</code>","text":"<p>               Bases: <code>GridSearchCV</code></p> <p>Class for grid search cross validation.</p> <p>Parameters:</p> <ul> <li> <code>similarity</code>               (<code>Similarity</code>)           \u2013            <p>Similarity instance setup with constant parameters, see <code>mosaic.Similarity</code> for available parameters. <code>low_memory</code> is not supported.</p> </li> <li> <code>clustering</code>               (<code>Clustering</code>)           \u2013            <p>Clustering instance setup with constant parameters, see <code>mosaic.Clustering</code> for available parameters.</p> </li> <li> <code>param_grid</code>               (<code>dict</code>)           \u2013            <p>Dictionary with parameters names (<code>str</code>) as keys and lists of parameter settings to try as values, or list of such dictionaries, in which case the grids spanned by each dictionary in the list are explored.</p> </li> <li> <code>gridsearch_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Dictionary with parameters to be used for <code>sklearn.model_selection.GridSearchCV</code> class. The parameter <code>estimator</code> is not supported and <code>param_grid</code> needs to be passed directly to the class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cv_results_</code>               (<code>dict of numpy (masked) ndarrays</code>)           \u2013            <p>A dict with keys as column headers and values as columns.</p> </li> <li> <code>best_estimator_</code>               (<code>estimator</code>)           \u2013            <p>Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data.</p> </li> <li> <code>best_score_</code>               (<code>float</code>)           \u2013            <p>Mean cross-validated score of the best_estimator.</p> </li> <li> <code>best_params_</code>               (<code>dict</code>)           \u2013            <p>Parameter setting that gave the best results on the hold out data.</p> </li> <li> <code>best_index_</code>               (<code>int</code>)           \u2013            <p>The index (of the <code>cv_results_</code> arrays) which corresponds to the best candidate parameter setting.</p> </li> <li> <code>n_splits_</code>               (<code>int</code>)           \u2013            <p>The number of cross-validation splits (folds/iterations).</p> </li> </ul> Notes <p>Check out sklearn.model_selection.GridSearchCV for an overview of all available attributes and more detailed description.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import mosaic\n&gt;&gt;&gt; # create two correlated data sets\n&gt;&gt;&gt; traj = np.array([\n...     func(np.linspace(0, 20, 1000))\n...     for  func in (\n...         np.sin,\n...         lambda x: np.sin(x + 0.1),\n...         np.cos,\n...         lambda x: np.cos(x + 0.1),\n...     )\n... ]).T\n&gt;&gt;&gt; search = mosaic.GridSearchCV(\n...     similarity=mosaic.Similarity(),\n...     clustering=mosaic.Clustering(),\n...     param_grid={'resolution_parameter': [0.05, 0.2]},\n... )\n&gt;&gt;&gt; search.fit(traj)\nGridSearchCV(clustering=Clustering(),\n             param_grid={'clust__resolution_parameter': [0.05, 0.2]},\n             similarity=Similarity())\n&gt;&gt;&gt; search.best_params_\n{'clust__resolution_parameter': 0.2}\n&gt;&gt;&gt; search.best_estimator_\nPipeline(steps=[('sim', Similarity()),\n                ('clust', Clustering(resolution_parameter=0.2))])\n</code></pre> <p>Initialize GridSearchCV class.</p> Source code in <code>src/mosaic/gridsearch.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    similarity: Similarity,\n    clustering: Clustering,\n    param_grid: Dict,\n    gridsearch_kwargs: Dict = {},\n) -&gt; None:\n    \"\"\"Initialize GridSearchCV class.\"\"\"\n    self.similarity: Similarity = similarity\n    self.clustering: Clustering = clustering\n    self.gridsearch_kwargs: Dict = gridsearch_kwargs\n\n    if 'estimator' in self.gridsearch_kwargs:\n        raise NotImplementedError(\n            'Custom estimators are not supported. Please use the '\n            'sklearn class GirdSearchCV directly.',\n        )\n\n    if 'param_grid' in self.gridsearch_kwargs:\n        raise NotImplementedError(\n            \"Please pass 'param_grid' directly to the the class.\",\n        )\n\n    if similarity.get_params()['low_memory']:\n        raise NotImplementedError(\n            \"'low_memory' is currently not implemented.\",\n        )\n\n    if not param_grid:\n        raise ValueError(\n            'At least a single parameter needs to be provided',\n        )\n\n    self.pipeline = Pipeline([\n        (self._sim_prefix, self.similarity),\n        (self._clust_prefix, self.clustering),\n    ])\n\n    self.param_grid: Dict = {}\n    for param, values in param_grid.items():\n        if param in similarity.get_params():\n            self.param_grid[\n                f'{self._sim_prefix}__{param}'\n            ] = values\n        elif param in clustering.get_params():\n            self.param_grid[\n                f'{self._clust_prefix}__{param}'\n            ] = values\n            print('######################', self.param_grid)\n        else:\n            raise ValueError(\n                f\"param_grid key '{param}' is not available.\"\n            )\n\n    super().__init__(\n        estimator=self.pipeline,\n        param_grid=self.param_grid,\n        **self.gridsearch_kwargs,\n    )\n</code></pre>"},{"location":"reference/gridsearch/#mosaic.gridsearch.GridSearchCV.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Clusters the correlation matrix by Leiden clustering on a graph.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features)</code>)           \u2013            <p>Training vector, where <code>n_samples</code> is the number of samples and <code>n_features</code> is the number of features.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/mosaic/gridsearch.py</code> <pre><code>@beartype\ndef fit(\n    self,\n    X: FloatMax2DArray,\n    y: Optional[np.ndarray] = None,\n):\n    \"\"\"Clusters the correlation matrix by Leiden clustering on a graph.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features)\n        Training vector, where `n_samples` is the number of samples and\n        `n_features` is the number of features.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    return super().fit(X)\n</code></pre>"},{"location":"reference/similarity/","title":"similarity","text":"<p>Class for estimating correlation matrices.</p> <p>MIT License Copyright \u00a9 2021-2022, Daniel Nagel, Georg Diez All rights reserved.</p>"},{"location":"reference/similarity/#mosaic.similarity.Similarity","title":"<code>Similarity(*, metric='correlation', low_memory=False, normalize_method=None, use_knn_estimator=False)</code>","text":"<p>               Bases: <code>BaseEstimator</code></p> <p>Class for calculating the similarity measure.</p> <p>Parameters:</p> <ul> <li> <code>metric</code>               (<code>str</code>, default:                   <code>'correlation'</code> )           \u2013            <p>the correlation metric to use for the feature distance matrix. - <code>'correlation'</code> will use the absolute value of the Pearson   correlation - <code>'NMI'</code> will use the mutual information normalized by joined entropy - <code>'GY'</code> uses Gel'fand and Yaglom normalization[^1] - <code>'JSD'</code> will use the Jensen-Shannon divergence between the joint   probability distribution and the product of the marginal probability   distributions to calculate their dissimilarity Note: <code>'NMI'</code> is supported only with low_memory=False</p> </li> <li> <code>low_memory</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the input of fit X needs to be a file name and the correlation is calculated on the fly. Otherwise, an array is assumed as input X.</p> </li> <li> <code>normalize_method</code>               (<code>str</code>, default:                   <code>'geometric'</code> )           \u2013            <p>Only required for metric <code>'NMI'</code>. Determines the normalization factor for the mutual information: - <code>'joint'</code> is the joint entropy - <code>'max'</code> is the maximum of the individual entropies - <code>'arithmetic'</code> is the mean of the individual entropies - <code>'geometric'</code> is the square root of the product of the individual   entropies - <code>'min'</code> is the minimum of the individual entropies</p> </li> <li> <code>use_knn_estimator</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Can only be set for metric GY. If True, the mutual information is estimated reliably by a parameter free method based on entropy estimation from k-nearest neighbors distances[^3]. It considerably increases the computational time and is thus only advisable for relatively small data-sets.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>matrix_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The correlation-measure-based pairwise distance matrix of the data. It scales from [0, 1].</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import mosaic\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; data = np.array([np.cos(x), np.cos(x + np.pi / 6)]).T\n&gt;&gt;&gt; sim = mosaic.Similarity()\n&gt;&gt;&gt; sim.fit(data)\nSimilarity()\n&gt;&gt;&gt; sim.matrix_\narray([[1.       , 0.9697832],\n       [0.9697832, 1.       ]])\n</code></pre> Notes <p>The Pearson correlation coefficient is defined as</p> \\[\\rho_{X,Y} = \\frac{\\langle(X -\\mu_X)(Y -\\mu_Y)\\rangle}{\\sigma_X\\sigma_Y}.\\] <p>For the online (low memory) option the Welford algorithm<sup>2</sup> is used.</p> <p>The Jensen-Shannon divergence is defined as</p> \\[D_{\\text{JS}} = \\frac{1}{2} D_{\\text{KL}}(p(x,y)||M) + \\frac{1}{2} D_{\\text{KL}}(p(x)p(y)||M)\\;,\\] <p>where \\(M = \\frac{1}{2} [p(x,y) + p(x)p(y)]\\) is an averaged probability distribution and \\(D_{\\text{KL}}\\) denotes the Kullback-Leibler divergence.</p> <ol> <li> <p>Gel'fand, I.M. and Yaglom, A.M. (1957). \"Calculation of amount of information about a random function contained in another such function\". American Mathematical Society Translations, series 2, 12, pp. 199\u2013246.\u00a0\u21a9</p> </li> <li> <p>Welford algorithm, generalized to correlation. Taken from: Donald E. Knuth (1998). \"The Art of Computer Programming\", volume 2: Seminumerical Algorithms, 3<sup>rd</sup> edn., p. 232. Boston: Addison-Wesley.\u00a0\u21a9</p> </li> <li> <p>B.C. Ross, PLoS ONE 9(2) (2014), \"Mutual Information between Discrete and Continuous Data Sets\"\u00a0\u21a9</p> </li> </ol> <p>Initialize Similarity class.</p> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    metric: MetricString = 'correlation',\n    low_memory: bool = False,\n    normalize_method: Optional[NormString] = None,\n    use_knn_estimator: bool = False,\n):\n    \"\"\"Initialize Similarity class.\"\"\"\n    self.metric: MetricString = metric\n    self.low_memory: bool = low_memory\n    self.use_knn_estimator: bool = use_knn_estimator\n    if self.metric == 'NMI':\n        if normalize_method is None:\n            normalize_method = self._default_normalize_method\n    elif normalize_method is not None:\n        raise NotImplementedError(\n            'Normalize methods are only supported with metric=\"NMI\"',\n        )\n    self.normalize_method: NormString = normalize_method\n    if self.metric != 'GY' and self.use_knn_estimator:\n        raise NotImplementedError(\n            (\n                'The mutual information estimate based on k-nearest'\n                'neighbors distances is only supported with metric=\"GY\"'\n            ),\n        )\n</code></pre>"},{"location":"reference/similarity/#mosaic.similarity.Similarity.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Compute the correlation/nmi distance matrix.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@singledispatchmethod\n@beartype\ndef fit(\n    self,\n    X: Union[FloatMax2DArray, str],\n    y: Optional[ArrayLikeFloat] = None,\n):\n    \"\"\"Compute the correlation/nmi distance matrix.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    raise NotImplementedError('Fatal error, this should never be reached.')\n</code></pre>"},{"location":"reference/similarity/#mosaic.similarity.Similarity.fit_transform","title":"<code>fit_transform(X, y=None)</code>","text":"<p>Compute the correlation/nmi distance matrix and returns it.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Similarity</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>Similarity matrix.</p> </li> </ul> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@beartype\ndef fit_transform(\n    self,\n    X: Union[FloatMax2DArray, str],\n    y: Optional[ArrayLikeFloat] = None,\n) -&gt; FloatMatrix:\n    \"\"\"Compute the correlation/nmi distance matrix and returns it.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    Similarity : ndarray of shape (n_features, n_features)\n        Similarity matrix.\n\n    \"\"\"\n    self.fit(X)\n    return self.matrix_\n</code></pre>"},{"location":"reference/similarity/#mosaic.similarity.Similarity.transform","title":"<code>transform(X)</code>","text":"<p>Compute the correlation/nmi distance matrix and returns it.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Similarity</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>Similarity matrix.</p> </li> </ul> Source code in <code>src/mosaic/similarity.py</code> <pre><code>@beartype\ndef transform(\n    self,\n    X: Union[FloatMax2DArray, str],\n) -&gt; FloatMatrix:\n    \"\"\"Compute the correlation/nmi distance matrix and returns it.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n\n    Returns\n    -------\n    Similarity : ndarray of shape (n_features, n_features)\n        Similarity matrix.\n\n    \"\"\"\n    return self.fit_transform(X)\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Class with helper functions.</p> <p>MIT License Copyright \u00a9 2021-2022, Daniel Nagel All rights reserved.</p>"},{"location":"reference/utils/#mosaic.utils.savetxt","title":"<code>savetxt(filename, array, fmt, submodule=None, header=None)</code>","text":"<p>Save ndarray with user runtime information.</p> Source code in <code>src/mosaic/utils.py</code> <pre><code>def savetxt(filename, array, fmt, submodule=None, header=None):\n    \"\"\"Save ndarray with user runtime information.\"\"\"\n    header_generic = _get_rui(submodule)\n    if header:\n        header_generic = f'{header_generic}\\n\\n{header}'\n\n    np.savetxt(\n        filename,\n        array,\n        fmt=fmt,\n        header=header_generic,\n    )\n</code></pre>"},{"location":"reference/utils/#mosaic.utils.load_clusters","title":"<code>load_clusters(filename)</code>","text":"<p>Load clusters stored from cli.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Filename of cluster file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>clusters</code> (              <code>ndarray of shape (n_clusters, )</code> )          \u2013            <p>A list of arrays, each containing all indices (features) for each cluster.</p> </li> </ul> Source code in <code>src/mosaic/utils.py</code> <pre><code>@beartype\ndef load_clusters(filename: str) -&gt; Object1DArray:\n    \"\"\"Load clusters stored from cli.\n\n    Parameters\n    ----------\n    filename : str\n        Filename of cluster file.\n\n    Returns\n    -------\n    clusters : ndarray of shape (n_clusters, )\n        A list of arrays, each containing all indices (features) for each\n        cluster.\n\n    \"\"\"\n    comment = '#'\n    with open(filename) as clusters:\n        clusters_list = [\n            np.array(\n                cluster.split()\n            ).astype(int).tolist()\n            for cluster in clusters if not cluster.startswith(comment)\n        ]\n\n    # In case of clusters of same length, numpy casted it as a 2D array.\n    # To ensure that the result is an numpy array of list, we need to\n    # create an empty list, adding the values in the second step\n    clusters: Object1DArray = np.empty(len(clusters_list), dtype=object)\n    clusters[:] = clusters_list  # noqa: WPS362\n    return clusters\n</code></pre>"},{"location":"reference/utils/#mosaic.utils.save_clusters","title":"<code>save_clusters(filename, clusters)</code>","text":"<p>Save clusters from <code>mosaic.Clustering.clusters_</code> to txt file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Filename of cluster file.</p> </li> <li> <code>clusters</code>               (<code>ndarray of shape (n_clusters, )</code>)           \u2013            <p>A list of arrays, each containing all indices (features) for each cluster.</p> </li> </ul> Source code in <code>src/mosaic/utils.py</code> <pre><code>@beartype\ndef save_clusters(filename: str, clusters: Object1DArray):\n    \"\"\"Save clusters from `mosaic.Clustering.clusters_` to txt file.\n\n    Parameters\n    ----------\n    filename : str\n        Filename of cluster file.\n    clusters : ndarray of shape (n_clusters, )\n        A list of arrays, each containing all indices (features) for each\n        cluster.\n\n    \"\"\"\n    clusters_string = np.array(\n        [\n            ' '.join([str(state) for state in cluster])\n            for cluster in clusters\n        ],\n        dtype=str,\n    )\n    savetxt(\n        filename,\n        clusters_string,\n        fmt='%s',\n        submodule='clustering',\n        header=(\n            'In ith row are the indices listed (zero-indexed) corresponding '\n            'to cluster i.'\n        ),\n    )\n</code></pre>"},{"location":"tutorial/cv/","title":"Crossvalidation","text":""},{"location":"tutorial/cv/#cross-validation-of-parameters","title":"Cross-Validation of Parameters","text":"<p>Selecting the optimal parameters, e.g., <code>resolution_parameter</code>, or <code>n_clusters</code>, can be quite difficult. Here we show a short example how one can use cross-validation for optimizing the parameters. Nevertheless, one should keep in mind that the here used silhouette score is not optimal for our task.  Hence, the here obtained optimal parameters should be considered as a good first guess.</p> <p>Here a figure visualizing the optimal cluster value <code>n_clusters=12</code> and the code to produce it.</p> <p></p> <pre><code>import mosaic\nimport numpy as np\nimport prettypyplot as pplt\nfrom matplotlib import pyplot as plt\n\npplt.use_style(colors='tab20c', figsize=2.4)\n\n# traj = np.loadtxt(filename)\n\n# specify parameters grid\nn_clusters = np.arange(2, traj.shape[1])\nparams = {'n_clusters': n_clusters}\nsearch = mosaic.GridSearchCV(\n    similarity=mosaic.Similarity(),\n    clustering=mosaic.Clustering(\n        mode='kmedoids',\n        n_clusters=2,  # any dummy value is good here\n    ),\n    param_grid=params,\n).fit(traj)\n\n# plotting result\nfig, ax = plt.subplots()\nmean_score = search.cv_results_['mean_test_score']\nstd_score = search.cv_results_['std_test_score']\n\nax.fill_between(\n    n_clusters,\n    mean_score + std_score,\n    mean_score - std_score,\n    color='C2',\n)\nax.plot(n_clusters, mean_score + std_score, c='C1')\nax.plot(n_clusters, mean_score - std_score, c='C1')\nax.plot(n_clusters, mean_score, c='C0')\n\nax.set_xlim([0, traj.shape[1]])\nax.set_xlabel(r'$k$ no. of clusters')\nax.set_ylabel(r'silhouette score')\n\npplt.savefig('cv_silhouette.pdf')\n</code></pre>"},{"location":"tutorial/t4l_tutorial_github/","title":"MoSAIC workflow","text":"<p>This tutorial explains how to extract clusters for T4 Lysozyme using MoSAIC.</p> <p>Correlation-Based Feature Selection to Identify Functional Dynamcis in Proteins G. Diez, D. Nagel, and G. Stock, J. Chem. Theory Comput. 2022 18 (8), 5079-5088, 10.1021/acs.jctc.2c00337</p> <p>The assumption is that the necessary internal coordinates, such as contact distances, have already been calculated.</p> <p>A file with every 10000th frame of the 402 contact distances from</p> <p>Identification and Validation of Reaction Coordinates Describing Protein Functional Motion: Hierarchical Dynamics of T4 Lysozyme M. Ernst, S. Wolf and G. Stock (J. Chem. Theory Comput. 2017 13, 5076)</p> <p>is provided. Additionally, an index-file is provided that specifies the columns of the coordinate file. So, for example, the first line of the index-file contains</p> <p>1  5</p> <p>which means that the first column in the coordinate file corresponds to the minimal distance between the first and fifth residue.</p> <p>The data is loaded using the mosaic package, and the correlation matrix is calculated using the Similarity class and the correlation metric. Once the correlation matrix has been computed, the next step is to cluster the data using the Leiden algorithm with the constant Potts model.</p> In\u00a0[14]: Copied! <pre>import mosaic\nimport numpy as np\n\n\n# Load the data\ninternal_coords = np.loadtxt('./t4l_exampletraj_mindists.dat')\ninternal_coords_names = np.loadtxt(\n    './t4l_exampletraj_mindists_names.idx',\n).astype(int)\n\n# Calculate the correlation matrix\nsim = mosaic.Similarity(metric='correlation')\nsim.fit(internal_coords)\ncorrelation_matrix = sim.matrix_\n</pre> import mosaic import numpy as np   # Load the data internal_coords = np.loadtxt('./t4l_exampletraj_mindists.dat') internal_coords_names = np.loadtxt(     './t4l_exampletraj_mindists_names.idx', ).astype(int)  # Calculate the correlation matrix sim = mosaic.Similarity(metric='correlation') sim.fit(internal_coords) correlation_matrix = sim.matrix_ <p>In this example, a resolution parameter of gamma=0.5 is used. Depending on the size of the matrix and the value of the resolution parameter, the clustering might need some time (higher resolution parameters require more time). Therefore, a cutoff can be used for large matrices to mask all correlation entries below a certain threshold.</p> In\u00a0[15]: Copied! <pre># Cluster the correlation matrix\nclustering = mosaic.Clustering(\n    mode='CPM',\n    weighted=True,\n    resolution_parameter=0.5,\n)\nclustering.fit(correlation_matrix);\n</pre> # Cluster the correlation matrix clustering = mosaic.Clustering(     mode='CPM',     weighted=True,     resolution_parameter=0.5, ) clustering.fit(correlation_matrix); <p>Once the clustering process is completed, the next step is to visualize the matrix.</p> In\u00a0[16]: Copied! <pre>%matplotlib inline\nimport matplotlib.pyplot as plt\n\n\nfig, ax = plt.subplots()\nim = ax.pcolormesh(clustering.matrix_)\nax.invert_yaxis()  # origin to the upper left\nax.set_aspect('equal')  # 1:1 ratio\nax.set_xticks(clustering.ticks_)\nax.set_yticks(clustering.ticks_)\nax.set_xticklabels([])\nax.set_yticklabels([])\nax.set_xlabel('clusters')\nax.set_ylabel('clusters')\nax.grid(False)\nplt.colorbar(im, label=r'$|\\rho|$')\nplt.show()\n</pre> %matplotlib inline import matplotlib.pyplot as plt   fig, ax = plt.subplots() im = ax.pcolormesh(clustering.matrix_) ax.invert_yaxis()  # origin to the upper left ax.set_aspect('equal')  # 1:1 ratio ax.set_xticks(clustering.ticks_) ax.set_yticks(clustering.ticks_) ax.set_xticklabels([]) ax.set_yticklabels([]) ax.set_xlabel('clusters') ax.set_ylabel('clusters') ax.grid(False) plt.colorbar(im, label=r'$|\\rho|$') plt.show() <p>Sometimes it can be useful to sort the clusters by size before visualizing. This allows us to see which clusters are largest and play a key role in the process we want to study. To sort the clusters by size, we can first calculate the size of each cluster and sort them in descending order. We can then reorder the rows and columns of the matrix based on this sorted order. This way, the largest clusters will be in the upper left corner of the heatmap, while the smallest clusters will be in the lower right corner. Such a  reordering makes it easier to identify and interpret the larger, more meaningful clusters in the data.</p> In\u00a0[17]: Copied! <pre>idxs = np.argsort(\n    [len(cluster) for cluster in clustering.clusters_],\n)[::-1]\nclusters_sorted = clustering.clusters_[idxs]\nclusters_sorted_flattened = np.concatenate(clustering.clusters_[idxs])\n\n# sort the matrix accordingly\nmatrix_sorted = correlation_matrix[\n    np.ix_(clusters_sorted_flattened, clusters_sorted_flattened)\n]\nticks = np.cumsum([len(cluster) for cluster in clustering.clusters_[idxs]])\nticks = [0, *ticks[:-1]]  # ticks start with 0\n</pre> idxs = np.argsort(     [len(cluster) for cluster in clustering.clusters_], )[::-1] clusters_sorted = clustering.clusters_[idxs] clusters_sorted_flattened = np.concatenate(clustering.clusters_[idxs])  # sort the matrix accordingly matrix_sorted = correlation_matrix[     np.ix_(clusters_sorted_flattened, clusters_sorted_flattened) ] ticks = np.cumsum([len(cluster) for cluster in clustering.clusters_[idxs]]) ticks = [0, *ticks[:-1]]  # ticks start with 0  In\u00a0[18]: Copied! <pre># Perform the same plot again, but with sorted clusters\nfig, ax = plt.subplots()\nim = ax.pcolormesh(\n    matrix_sorted,\n    snap=True,\n    vmin=0,\n    vmax=1,\n)\nax.invert_yaxis()  # origin to the upper left\nax.set_aspect('equal')  # 1:1 ratio\nax.set_xticks(ticks[:4])  # we focus only on the first three clusters\nax.set_yticks(ticks[:4])\nax.set_xticklabels(np.arange(4)+1)\nax.set_yticklabels(np.arange(4)+1)\nax.set_xlabel('clusters')\nax.set_ylabel('clusters')\nax.grid(True)\nplt.colorbar(im, label=r'$|\\rho|$')\nplt.show()\n</pre> # Perform the same plot again, but with sorted clusters fig, ax = plt.subplots() im = ax.pcolormesh(     matrix_sorted,     snap=True,     vmin=0,     vmax=1, ) ax.invert_yaxis()  # origin to the upper left ax.set_aspect('equal')  # 1:1 ratio ax.set_xticks(ticks[:4])  # we focus only on the first three clusters ax.set_yticks(ticks[:4]) ax.set_xticklabels(np.arange(4)+1) ax.set_yticklabels(np.arange(4)+1) ax.set_xlabel('clusters') ax.set_ylabel('clusters') ax.grid(True) plt.colorbar(im, label=r'$|\\rho|$') plt.show() <p>Great! By applying clustering analysis to our MD data, we have identified three distinct clusters (1, 2, and 3) that describe independent processes. We have also observed that the majority of coordinates do not belong to a large cluster because they feature very few correlations with other coordinates (all these coordinates are simply combined here as cluster 4). This suggests that the coordinates in cluster 4 can be discarded as they do not contribute significantly to the dynamics of the system.</p> <p>Now we need to extract the coordinates of the residues belonging to a particular cluster, e.g., cluster 1, and visualize them as a 3D structure. To accomplish this, we will use the open source version of PyMOL, a powerful visualization tool that allows us to render and manipulate molecular structures (https://pymol.org/2/#opensource).</p> <p>To create a PyMOL script to achieve this, we first generate a string that contains all the information about the residues in this cluster. We can use the cluster assignments obtained earlier and the topology file of the simulated system to retrieve the atom names and coordinates of the residues in the cluster. Once we have this information, we can format it into a PyMOL script that selects and colors the residues in cluster 1.</p> <p>After generating the PyMOL script, we can run it using PyMOL's command-line interface to generate a 3D structure of the cluster. Finally, we will save the structure in a .png format.</p> <p>The PyMOL settings provided here are just an example and can be adjusted to suit the user's preferences.</p> In\u00a0[19]: Copied! <pre>import pymol\nfrom IPython.display import Image\npymol.cmd.feedback('disable', 'all', 'everything')  # suppress pymol output\n</pre> import pymol from IPython.display import Image pymol.cmd.feedback('disable', 'all', 'everything')  # suppress pymol output In\u00a0[20]: Copied! <pre># create structure plots for the first three MoSAIC clusters\nfor cluster in range(3):\n    pymol_cmd = \"\"\"\n        reinitialize; load t4l_structure.pdb;\n        set cartoon_discrete_colors, on;\n        util.cbss(\"all\",\"silver\",\"silver\",\"white\",_self=cmd);\n        bg_color white;\n        set ray_trace_mode,  1;\n        set ray_texture, 5;\n        set ray_trace_fog, 0;\n        set antialias, 2;\n        set stick_radius, .2;\n        set sphere_scale, .3;\n        set sphere_scale, .2, elem H;\n        set stick_quality, 50;\n        set sphere_quality, 4;\n        set ambient, 0.1;\n        set shininess, 10;\n        set specular, 1;\n        set reflect, .5;\n        set dash_gap, 0;\n        set dash_color, red;\n        set dash_length, .05;\n        set dash_round_ends, 0;\n        set dash_radius, .2;\n        set depth_cue, 0;\n        set label_size, 0;\n        set_view (\\\n             0.155398622,    0.833652616,    0.529968441,\\\n             0.252840698,    0.485050529,   -0.837133050,\\\n            -0.954944849,    0.264088452,   -0.135405213,\\\n             0.000078902,   -0.000241295, -156.730316162,\\\n            19.574779510,   34.417434692,   46.308376312,\\\n           128.238204956,  185.230773926,  -20.000000000 );\n    \"\"\"\n    for num, coord in enumerate(clusters_sorted[cluster]):\n        c1, c2 = internal_coords_names[coord];\n        pymol_cmd += f'distance dist{num}, {c1}/CA, {c2}/CA ;\\n'\n        pymol_cmd += f'select CA{num}, {c1}/CA or {c2}/CA ;\\n'\n        pymol_cmd += f'show spheres, CA{num} ;\\n'\n    pymol_cmd += f'ray 800; 800; png t4l_cluster{cluster + 1}.png;'\n    pymol.cmd.do(pymol_cmd);\n</pre> # create structure plots for the first three MoSAIC clusters for cluster in range(3):     pymol_cmd = \"\"\"         reinitialize; load t4l_structure.pdb;         set cartoon_discrete_colors, on;         util.cbss(\"all\",\"silver\",\"silver\",\"white\",_self=cmd);         bg_color white;         set ray_trace_mode,  1;         set ray_texture, 5;         set ray_trace_fog, 0;         set antialias, 2;         set stick_radius, .2;         set sphere_scale, .3;         set sphere_scale, .2, elem H;         set stick_quality, 50;         set sphere_quality, 4;         set ambient, 0.1;         set shininess, 10;         set specular, 1;         set reflect, .5;         set dash_gap, 0;         set dash_color, red;         set dash_length, .05;         set dash_round_ends, 0;         set dash_radius, .2;         set depth_cue, 0;         set label_size, 0;         set_view (\\              0.155398622,    0.833652616,    0.529968441,\\              0.252840698,    0.485050529,   -0.837133050,\\             -0.954944849,    0.264088452,   -0.135405213,\\              0.000078902,   -0.000241295, -156.730316162,\\             19.574779510,   34.417434692,   46.308376312,\\            128.238204956,  185.230773926,  -20.000000000 );     \"\"\"     for num, coord in enumerate(clusters_sorted[cluster]):         c1, c2 = internal_coords_names[coord];         pymol_cmd += f'distance dist{num}, {c1}/CA, {c2}/CA ;\\n'         pymol_cmd += f'select CA{num}, {c1}/CA or {c2}/CA ;\\n'         pymol_cmd += f'show spheres, CA{num} ;\\n'     pymol_cmd += f'ray 800; 800; png t4l_cluster{cluster + 1}.png;'     pymol.cmd.do(pymol_cmd); In\u00a0[21]: Copied! <pre>Image('./t4l_cluster1.png')\n</pre> Image('./t4l_cluster1.png') Out[21]: In\u00a0[22]: Copied! <pre>Image('./t4l_cluster2.png')\n</pre> Image('./t4l_cluster2.png') Out[22]: In\u00a0[23]: Copied! <pre>Image('./t4l_cluster3.png')\n</pre> Image('./t4l_cluster3.png') Out[23]:"},{"location":"tutorial/t4l_tutorial_github/#tutorial-uncovering-independent-processes-in-molecular-dynamics-data-using-mosaic-and-pymol-visualization","title":"Tutorial: Uncovering Independent Processes in Molecular Dynamics Data using MoSAIC and PyMOL Visualization\u00b6","text":""},{"location":"tutorial/t4l_tutorial_github/#computing-the-correlation","title":"Computing the Correlation\u00b6","text":""},{"location":"tutorial/t4l_tutorial_github/#clustering","title":"Clustering\u00b6","text":""},{"location":"tutorial/t4l_tutorial_github/#conclusion","title":"Conclusion\u00b6","text":"<p>In conclusion, our MoSAIC analysis of the MD data allowed us to identify three important clusters of coordinates, each describing independent processes. By visualizing these clusters using PyMOL, we were able to extract their coordinates and gain insights into their structural characteristics.</p> <p>Additionally, we found that the majority of coordinates were not significantly correlated with any other coordinate, indicating that they can be discarded from further analysis. This approach can be useful for identifying key coordinates and processes in large MD datasets and can aid in understanding complex biological processes.</p>"}]}